# 관계형 데이터베이스 설계

---

## 1. 좋은 관계형 설계의 특징

<br>

> 불필요한 중복 없이 정보를 저장하고 쉽게 검색이 가능

<br>

### 1) 중복의 문제

<br>

| ID | name  | salary       | dept_name | building | budget |
|------------|------|------------|----|------------|------|
| 1        | Yang | 95000         | Physics | Watson        | 70000   |
| 2        | Park   | 90000       | Physics | Watson        | 70000    |
| 3        | Lee | 60000         | Finance | Painter        | 120000         |
| 4        | Cho  | 75000    | Finance | Painter        | 120000    |

<br>

- dept_name, building, budget과 같은 학과의 정보를 중복 저장하여 손해
- budget 수정 시 관련 학과를 모두 수정하지 않으면 일관성을 잃을 수 있음

### 2) Null 문제

<br>

- 학과만 신설할 경우 교수 채용 전이라면 ID, name, salary에 null 값을 가지게 됨

### 3) 분해

> 스키마에 문제가 있다면 분해하여 해결 가능

<br>

이전의 스키마를 교수와 학과 스키마로 분해하면 관련 문제를 해결할 수 있음

- 분해로 인해 정보의 손실이 발생한다면 분해하지 말아야 함
- **무손실 분해** : R = πR1(R) ⋈ πR2(R)
- **손실 분해** : R ≠ πR1(R) ⋈ πR2(R)

<기존>
| ID | name  | street       | city | salary |
|------------|------|------------|------------|-----|
| 1        | Yang | Main         | Perryridge | 95000        |
| 2        | Park   | North       | Hampton | 90000        |

<분해>
| ID | name  | |street       | city | salary |
|------------|------|-----|------------|------------|-----|
| 1        | Yang || Main        | Perryridge | 95000        |
| 2        | Park || North       | Hampton | 90000        |

<자연 조인>

| ID | name  | street       | city | salary |
|------------|------|------------|------------|-----|
| 1        | Yang | Main         | Perryridge | 95000        |
| 1        | Yang | North       | Hampton | 90000         |
| 2        | Park | Main         | Perryridge | 95000        |
| 2        | Park | North       | Hampton | 90000        |

- 분해 후 자연 조인 결과가 기존의 릴레이션과 다름
- 실제 거주 위치 급여와 관련 없는 이름과 조인이 일어나게 되어서 불필요한 정보가 생성됨
- 이름과 주소 또는 급여와의 연관 관계 정보가 손실됨

<br>

## 2. 함수 종속을 사용한 분해

<br>

### 1) 적법한 인스턴스

> 데이터베이스의 모든 릴레이션 인스턴스가 실제 세계의 제약 조건을 만족

<br>

### 2) 함수 종속

> 어떤 속성 값이 다른 속성 값을 결정할 수 있는 관계

<br>

- r(R)인스턴스 내 모든 튜플의 쌍 t1, t2가 t1[X] = t2[X]이면, t1[Y] = t2[Y]를 만족하면 **함수 종속** X → Y를 만족
- 함수 종속 X → Y이 성립하면 X는 r(R)인스턴스의 **수퍼키**라는 것을 의미
- 함수 종속 집합 F를 만족하는 r(R)인스턴스에 대해 **F는 r(R)을 보존**한다고 함
- R1 ∩ R2 → R1 또는 R1 ∩ R2 → R2이면 R을 R1과 R2로 분해하는 것은 **무손실 분해**

<br>

## 3. 정규형

<br>

### 1) 보이스-코드 정규형(BCNF)

#### 정의

> 다음 중 적어도 하나라도 만족하면 함수 종속의 집합 F와 관련하여 릴레이션 스키마 R은 BCNF
> - X → Y가 자명한 함수 종속
> - X가 스키마 R의 수퍼 키

<br>

#### 분해

> BCNF 형태가 아닌 스키마는 X → Y에서 BCNF의 정의를 만족하지 않는 경우가 있다면
> - X ∪ Y
> - R - (Y - X)
> 두 개의 스키마로 분해할 수 있음

<br>

#### 예시
1. in_dep (ID, name, salary, dept_name, building, budget)에서 dept_name -> budget이 성립하지만 자명하지도 수퍼키도 아니므로 BCNF가 아님
2. dept_name -> {building, budget}으로 분해
3. X ∪ Y = (dept_name, building, budget), R - (Y - X) = (ID, name, dept_name, salary)로 분해
4. 각각의 릴레이션에서 dept_name, ID가 수퍼키로 BCNF를 만족

<br>

#### 단점
> BCNF는 종속성을 보존하지 않음

1. "학생은 두 명 이상의 지도교수를 둘 수 있지만 주어진 학과에서 최대 한 명의 지도교수를 가진다"라는 제약조건
2. dept_advisor(s_ID, i_ID, dept_name)은 BCNF 분해 규칙에 따라 (s_ID, i_ID)와 (i_ID, dept_name)으로 분해 가능  
3. 학생은 주어진 학과에서 최대 한 명의 지도교수를 가진다라는 s_ID, dept_name -> i_ID의 종속성을 잃어 버림

<br>

### 2) 제3정규형(3NF)

#### 정의

> 다음 중 적어도 하나라도 만족하면 함수 종속의 집합 F와 관련하여 릴레이션 스키마 R은 3NF
> - X → Y가 자명한 함수 종속
> - X가 스키마 R의 수퍼 키
> - Y - X에 속한 각 속성 A는 R의 후보 키

이전의 예시에서 s_ID, dept_name -> i_ID의 s_ID와 dept_name은 각각 후보키이므로 dept_advisor(s_ID, i_ID, dept_name)는 3NF

<br>

#### BCNF vs 3NF

> SQL에서 주 키 제약 조건 이외의 함수 종속 확인이 어려우므로 BCNF 사용을 권장

<br>

#### 함수 종속 기반 정규형의 단점
>정보의 불필요한 중복

교수가 두명의 자식(David, William)과 두개의 전화번호(111-1111, 222-2222)가 있을 때
1. (1, David, 111-1111)
2. (1, David, 222-2222)
3. (1, William, 111-1111)
4. (1, William, 222-2222)  

- 두 개의 튜플만 사용할 경우 대응되어야 할 일부 튜플이 적용 안됨
- 네 개의 튜플을 사용할 경우 정보의 불필요한 중복이 발생
